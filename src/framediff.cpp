

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <stdio.h>
#include <iostream>
#include <sys/time.h>
#include <unistd.h>
#include <sstream>
#include <stdlib.h>
#include <inttypes.h>
#include <glob.h>
#include <vector>
#include <fcntl.h>
#include <linux/kd.h>
#include <sys/ioctl.h>
#include <boost/algorithm/string.hpp> // include Boost, a C++ library
#include <sys/stat.h>
#include <sys/types.h>
#include <utime.h>
#include <stdlib.h>
#include <fcntl.h>
#include <errno.h>
#include <unistd.h>
#include <syslog.h>


#include <fstream>
#include <iomanip>
#include <unistd.h>
#include <cstdio>
#include <errno.h>
#include <linux/videodev2.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <unistd.h>

#include <vector>
#include <stdio.h>



//openCV
#include <opencv2/opencv.hpp>
#include <opencv/cv.hpp>
#include <opencv2/videoio.hpp>
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/core/core.hpp"


#include <iostream>
#include <stdio.h>
#include <stdlib.h>


#include "cgicc/Cgicc.h"
#include "cgicc/HTTPHTMLHeader.h"
#include "cgicc/HTMLClasses.h"

#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/foreach.hpp>

using namespace std;
using namespace cgicc;
using namespace cv;
using boost::property_tree::ptree;
using boost::property_tree::read_json;
using boost::property_tree::write_json;



const Scalar SCALAR_BLACK = Scalar(0.0,0.0,0.0);
const Scalar SCALAR_WHITE = Scalar(255.0,255.0,255.0);
const Scalar SCALAR_BLUE = Scalar(255.0,0.0,0.0);
const Scalar SCALAR_GREEN = Scalar(0.0,255.0,0.0);
const Scalar SCALAR_RED = Scalar(0.0,0.0,255.0);



// Global variables
Mat myframe; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Mat adjustedOut;
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int cannyLow = 80;
int cannyHigh=210; //thresholds for canny algorithm
int keyboard; //input from keyboard
void help();
void processVideo(string videoFilename, float learningrate, int daynum, int maxframes);
void processImages(char* firstFrameFilename);
void processExperiment(string pathname, long startframe, long endframe, string filetype);

static void on_trackbar( int, void* )
{
   // resizeWindow("Simple Ass BS", 800, cannyHigh);
  // imshow( "Adjusted Out", adjustedOut );
}

int main(int argc, char* argv[])
{

    //check for the input parameter correctness
    if(argc < 5) {
        cerr <<"Incorret input list" << endl;
        cerr <<"exiting..." << endl;
        return EXIT_FAILURE;
    }
    //create GUI windows
    namedWindow("Frame");
    namedWindow("Simple Ass BS");
   


    //make trackbars
    string TrackbarName1 = "Canny High";
    string TrackbarName2 = "Canny Low";
    int high_slider;
	int learningrate=75; //default
    
    createTrackbar( TrackbarName1, "Simple Ass BS", &cannyHigh, 255, on_trackbar );
	    createTrackbar( TrackbarName2, "Simple Ass BS", &cannyLow, 255, on_trackbar );
    on_trackbar( cannyHigh, 0 );

	
    stringstream apath; // holds the paths
	stringstream filetype; //hold the file type
	int startframe=0;
	int endframe= 0; 
	
	

    for (int i=1; i < argc; i+=2){
	char sw = argv[i][1];
	cout << "arg i=" << sw << endl;
	
	switch (sw) {
		case 'd':
		case 'D':
		case 'p':
		case 'P':
			apath << argv[i+1];
		break;

		case 'f':
		case 'F':
			filetype << (argv[i+1]);
		break;

		case 's':
		case 'S':
			startframe = atoi(argv[i+1]);
		break;

		case 'e':
		case 'E':
			endframe = atoi(argv[i+1]);
		break;

		
		case 'l':
		case 'L':
			cannyLow = atoi(argv[i+1]);
		break;

		case 'h':
		case 'H':
			cannyHigh = atoi(argv[i+1]);
		break;

			

	}//end argument swtch


    }// end for each argument


	//process experiment
	processExperiment(apath.str(), startframe, endframe, filetype.str());
	

	
 
    //destroy GUI windows
    destroyAllWindows();
    return EXIT_SUCCESS;
}


bool emptypixel(int x, int y){

}//end test for empty pixels


unsigned char readpixelmap(int x, int y){


}//end readpixelmap 

int setpixelmap(int setvalue){

}//end set pixelmap

void flood(int x, int y, int setvalue) {

	if (readpixelmap(x,y) == setvalue) return;
	if (emptypixel(x,y)) return;

	if (!readpixelmap(x,y)){ 
		setpixelmap(setvalue);
		
	}//end if pixel hadn't been assigned yet
	if (!readpixelmap(x+1,y)){ 
		setpixelmap(setvalue);
	}//end if pixel hadn't been assigned yet
	if (!readpixelmap(x,y+1)){ 
		setpixelmap(setvalue);
	}//end if pixel hadn't been assigned yet
	if (!readpixelmap(x+1,y+1)){ 
		setpixelmap(setvalue);
	}//end if pixel hadn't been assigned yet
	if (!readpixelmap(x-1,y)){ 
		setpixelmap(setvalue);
	}//end if pixel hadn't been assigned yet
	if (!readpixelmap(x,y-1)){ 
		setpixelmap(setvalue);
	}//end if pixel hadn't been assigned yet
	if (!readpixelmap(x-1,y-1)){ 
		setpixelmap(setvalue);
	}//end if pixel hadn't been assigned yet
	if (!readpixelmap(x-1,y+1)){ 
		setpixelmap(setvalue);
	}//end if pixel hadn't been assigned yet
	if (!readpixelmap(x+1,y-1)){ 
		setpixelmap(setvalue);
	}//end if pixel hadn't been assigned yet

}//end flood the non zero pixels that are connected

void defineBlobs(char* imageFilename){

	Mat connectivity;
	Mat sourceimage;
	int blobcounter=0;

	Size s = sourceimage.size();

	int imageheight = s.height;
	int imagewidth = s.width;

	//interate over all pixels in an image_and define their connectivity
	for (int j=0; j < imageheight; j++){	
		for (int i=0; i < imagewidth; i++) {
			if (!emptypixel(i,j)){
				flood(i,j,blobcounter++);
			}//end if pixel has value
		}//end for each row
	}//end for each column


}//end defineBlobs

string padded(long c) {

	stringstream number;
	number << setfill('0') << setw(6) << c;

	return number.str();
}//end padded


void processExperiment(string pathname, long startframe, long endframe, string filetype) {




	for (int i=startframe; i <= endframe; i+=2){

		//generate filename
		stringstream firstname, secondname;
		firstname << pathname << filetype << padded(i) << ".png" ;
		secondname << pathname << filetype << padded(i+1) << ".png" ;
		stringstream sss,ss;
		sss << pathname << filetype << "diff" << padded(i) << ".png";
		ss << pathname << filetype << "raw" << padded(i) << ".png";

		//read in image files
		Mat first=imread(firstname.str());
		Mat second=imread(secondname.str());

		//do simple subtraction
		Mat noprocess = first.clone();
		noprocess = second - noprocess;
		imwrite(ss.str().c_str(),noprocess);
		

		
		//make the background mask
		Mat canny_output;
		vector<vector<Point> > contours;
		vector<Vec4i> hierarchy;
	
		Mat canny_output_final;
		vector<vector<Point> > contoursfinal;
		vector<Vec4i> hierarchyfinal;

		//processs images 
		 cvtColor( first, first, COLOR_BGR2GRAY );
		 equalizeHist(first,first);
		blur( first, first, Size(5,5) );		
		cout << "cannylow"<< cannyLow << " canny high" << cannyHigh << endl;				
		Canny( first, canny_output, cannyLow, cannyHigh, 3 );
		findContours( canny_output, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0) );
		Mat firstdrawing = (Mat::zeros( canny_output.size(), CV_8UC1 ));

		cvtColor( second, second, COLOR_BGR2GRAY );
		 equalizeHist(second,second);
		blur( second, second, Size(5,5) );		
		cout << "cannylow"<< cannyLow << " canny high" << cannyHigh << endl;				
		Canny( second, canny_output_final, cannyLow, cannyHigh, 3 );
		findContours( canny_output_final, contoursfinal, hierarchyfinal, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0) );
		Mat seconddrawing = (Mat::zeros( canny_output_final.size(), CV_8UC1 ));

		


		for( size_t j = 0; j< contours.size(); j++ )
			 {
			  
			   Scalar color = SCALAR_WHITE;
			   drawContours( firstdrawing, contours, (int)j, color, 1, 8, hierarchy, 0, Point() );


			 }

		for( size_t j = 0; j< contoursfinal.size(); j++ )
			 {
			  
			   Scalar color = SCALAR_WHITE;
			   drawContours( seconddrawing, contoursfinal, (int)j, color, 1, 8, hierarchy, 0, Point() );


			 }
		

		seconddrawing = seconddrawing - firstdrawing;
		
		
		imshow("Frame", seconddrawing);
		//imshow("Simple Ass BS", arnold);
		
		imwrite(sss.str().c_str(),seconddrawing);

		

		


	}//end for each frame



}//end process experiment

